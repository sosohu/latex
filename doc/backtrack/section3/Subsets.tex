    
\begin{description}
    \item{\textbf{问题}}:\\
Given a set of distinct integers, nums, return all possible subsets.\\
\textit{(leetcode 78)}
	\item{\textbf{举例}}:\\
If nums = (1,2,3), a solution is:\\
\\
(\\
  (3),\\
  (1),\\
  (2),\\
  (1,2,3),\\
  (1,3),\\
  (2,3),\\
  (1,2),\\
  ()\\
)
	\item{\textbf{Note}}:\\
Elements in a subset must be in non-descending order.\\
The solution set must not contain duplicate subsets.\\
    \item{\textbf{回溯}} : \fbox{时间复杂度O($2^n$), 空间复杂度O(n)}
    \\其实这是一道枚举题目,枚举每个元素包不包含进来两种情况即可.它是没有任何约束条件的回溯,一条道走到黑都是解.
    \begin{lstlisting}
void backtrack(vector<vector<int> > &result, vector<int> &track,
				vector<int> &S, int pos, int n){
	if(pos == n){
		result.push_back(track);
		return;
	}
	track.push_back(S[pos]);
	backtrack(result, track, S, pos+1, n);
	track.pop_back();
	backtrack(result, track, S, pos+1, n);
}

vector<vector<int> > subsets(vector<int> &S) {
	sort(S.begin(), S.end());
	int n = S.size();
	vector<vector<int> > result;
	vector<int> track;
	backtrack(result, track, S, 0, n);
	return result;
}
    \end{lstlisting}
\end{description}
